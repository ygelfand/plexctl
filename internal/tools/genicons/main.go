package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"

	"golang.org/x/net/html"
)

const (
	cheatSheetURL = "https://www.nerdfonts.com/cheat-sheet"
	outputFile    = "pkg/nerdfonts/icons.go"
)

func main() {
	fmt.Println("Fetching Nerd Fonts cheat sheet...")
	resp, err := http.Get(cheatSheetURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading body: %v\n", err)
		os.Exit(1)
	}

	glpyhs := findGlyphScript(string(body))
	if glpyhs == "" {
		fmt.Fprintln(os.Stderr, "Could not find Nerd Font glyphs object in HTML")
		os.Exit(1)
	}

	icons := parseGlyphs(glpyhs)

	generateGoFile(icons)
}

func generateGoFile(glyphs map[string]string) {
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	fmt.Fprintln(f, "package nerdfonts")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "// Code generated by internal/tools/genicons. DO NOT EDIT.")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "var Icons = map[string]string{")

	keys := make([]string, 0, len(glyphs))
	for k := range glyphs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		hex := glyphs[k]
		char := hexToChar(hex)
		fmt.Fprintf(f, "\t%q: %q,\n", k, char)
	}

	fmt.Fprintln(f, "}")
}

func findGlyphScript(htmlData string) string {
	doc, err := html.Parse(strings.NewReader(htmlData))
	if err != nil {
		panic(err)
	}

	var scriptContent string
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "script" && n.FirstChild != nil {
			if strings.Contains(n.FirstChild.Data, "const glyphs") {
				scriptContent = n.FirstChild.Data
				return
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)
	return scriptContent
}

func parseGlyphs(js string) map[string]string {
	start := strings.Index(js, "{")
	end := strings.LastIndex(js, "}")
	if start == -1 || end == -1 {
		panic("could not find object literal")
	}
	obj := js[start : end+1]
	obj = removeTrailingComma(obj)
	var glyphs map[string]string
	if err := json.Unmarshal([]byte(obj), &glyphs); err != nil {
		panic(err)
	}
	return glyphs
}

func removeTrailingComma(js string) string {
	lastBrace := strings.LastIndex(js, "}")
	if lastBrace == -1 {
		panic("no closing brace found")
	}

	i := lastBrace - 1
	for i >= 0 && (js[i] == ' ' || js[i] == '\t' || js[i] == '\n' || js[i] == '\r') {
		i--
	}

	if i >= 0 && js[i] == ',' {
		js = js[:i] + js[i+1:]
	}

	return js
}

func hexToChar(hex string) string {
	var r rune
	fmt.Sscanf(hex, "%x", &r)
	return string(r)
}
